*t7ko.txt*	Set of multi-purpose plugins written by Ivan Tishchenko

Author: Ivan Tishchenko (t7ko AT mail DOT ru)
For Vim version 6.3 and above
Last change: 2005 June 11

NOTE: I've written that these plugins are for "Vim version 6.3 and above".  
This doesn't mean that this won't work on previous version.  I just didn't 
test it on them.  If you did, write me please about results whenever they 
were successful or not to |t7ko-bug-reporting|.

NOTE: If you are going to use these plugins, please, read sections 
|t7ko-intro| and |t7ko-acknowledgements|.  They are tiny, really.  Section 
|t7ko-plugins| explains how to use plugins, in general.  All the rest is 
descriptions of plugins.  Also I recommend you to read that brief 
description of the plugin in the beginning of the section before using 
plugin.

		Contents~

1. Overview                                 |t7ko-intro|
2. Acknowledgements                         |t7ko-acknowledgements|
3. Plugins                                  |t7ko-plugins|
3.1.  Abbreviations (abbr)                  |t7ko--abbr|
3.2.  Align (align)                         |t7ko--align|
3.3.  Diff (diff)                           |t7ko--diff|
3.4.  Floating point operations (float)     |t7ko--float|
3.5.  Matematika-like loops (mat)           |t7ko--mat|
3.6.  Position handling (position)          |t7ko--position|
3.7.  Sessions management (sess)            |t7ko--sess|
3.8.  Sorting (sort)                        |t7ko--sort|
3.9.  Text (text)                           |t7ko--text|
3.10. Making lines unique (uniq)            |t7ko--uniq|
3.11. Enabling diff under Windows (windiff) |t7ko--windiff|


==============================================================================
							       *t7ko-intro*
1. Overview~

First of all, sorry for my terrible English.

These plugins were written by me during quite a long time.  I just wrote 
functions and commands for all those operations, that was often necessary 
for me to do and modified them when my necessities changed.  I'm not sure, 
that these will be helpful to anybody else but me, but I hope so.

						       *t7ko-bug-reporting*
Bug reports and any comments and opinions on these plugins are welcome and 
will be highly appreciated.  If you have some remarks on documentation 
(style or spelling), write me too.  Usually I read my mail at least three 
times a week, so I'll answer you quite fast.  My e-mail is 
{t7ko-AT-mail-DOT-ru}.  Note that my native is Russian, so you may write me 
in Russian too.

Also I should let you know, that I like elegant code.  And I like it so 
much, that I'm ready to hear any your opinion about my coding style and 
technique and advices of how to make them better.  I will discuss them with 
you with my great pleasure, if you want so.  And if one or another idea 
will seem to be nice, I'll make it a reality in my plugins.  Thanks in 
advice.


==============================================================================
						    *t7ko-acknowledgements*
2. Acknowledgements~

I'd like to thank very much all those people, who helped me to create this 
plugin-set with their advices or code snippets, and also all those who will 
help me to develop it henceforward.  (If you also want to help, see 
|t7ko-bug-reporting|).

First, thanks to Yury Arapov, who gave me some ideas for these plugins.  
And to by Nall-ohki for his vimtip #894.  To Robert Webb, whose example of 
sorting lines I included in plugin |t7ko--sort| as a part.

Well, now this list is quite tiny, but I hope it will grow.


==============================================================================
							     *t7ko-plugins*
3. Plugins~

To begin with, I don't like too much the way Vim loads plugins by default.  
He just finds all files in plugin-directory and loads them, so all the 
commands, mappings and functions are loaded, even if one doesn't want them.  
The same concerns my plugins.  Therefore I designed my plugins in such a 
way that they are loaded only when required using command |:PlugIn| and can 
be unloaded using |:PlugOut| when no longer necessary.

Definition of each plugin resides in detached file in directory 
{plugindir}/t7ko ({plugindir} designates here the directory where t7ko.vim 
lies).  Name of file with '.vim' removed is the name of plugin it defines.  
These names are to be used as arguments to |:PlugIn| and |:PlugOut| 
commands.

Here are described basic commands and function to load and unload plugins.

NOTE that I don't use return-values of function (described here and in all 
subsequent sections) to determine if they complete their work successfully.  
I just let errors, generated by commands they use, to go uncaught to 
caller, or call |:echoerr| if I detect error myself. NOTE also that there 
is some number of function and commands which go in pairs.  This is because 
of I discovered once, that Vim behaves strangely if I use |:if| or |:while| 
in a command definition.  May be, this was because I made something wrong, 
but I didn't find how to deal with it.  And since then for each command 
(except trivial ones) I declare function which performs everything I need, 
and then just call it in command.

					       *:PlugIn* *t7ko-plugging-in*
:PlugIn {plugin-name} ...
		Loads plugins specified as arguments.  If any plugin 
		specified is already loaded, command reports error.  Note 
		that you may use completion if you are lazy to type full 
		{plugin-name}.  :)  Up to 20 arguments are allowed.

				   *:PlugInRequire* *t7ko-plugging-require*
:PlugInRequire {plugin-name} ...
		Loads those of plugins specified as arguments that are not 
		yet loaded.  If any plugin specified is already loaded, 
		command doesn't report error or any message.  Note that you 
		may use completion as in |:PlugIn|.  Up to 20 arguments are 
		allowed.

					     *:PlugOut* *t7ko-plugging-out*
:PlugOut {plugin-name} ...
		Unloads all the plugins specified as arguments.  Actually 
		it calls command :PlugOut{Capitalized-plugin-name} for each 
		{plugin-name} specified.  Each plugin, when loaded, defines 
		that command which deletes all the names and mappings that 
		were defined when loading plugin.  It also restores values 
		of all the options that were changed.  For example, plugin 
		windiff |t7ko--windiff| when loaded changes 'diffexpr' 
		option.  So when plugged out it restores value that option 
		has before loading.  Note that if you changed those options 
		after plugging in, the result of plugging out is undefined 
		(I mean it's not known that this option will be restored or 
		left as is; if you want to know what will happen in version 
		of plugin you have, you may check out its source, but 
		future version may change its behaviour).  Note also that 
		here, like in |:PlugIn|, you also may use completion.

		Up to 20 arguments are allowed.

					      *Plugged()* *t7ko-is-plugged*
Plugged({plugin-name})
		Returns true if plugin {plugin-name} is plugged in, and 
		false otherwise.


==============================================================================
							       *t7ko--abbr*
3.1.  Abbreviations (abbr)~

This plugin intended for those who often writes texts.  I'm not sure this 
plugin will help to those who 1) is not Russian, and 2) didn't study at 
institute or so.

Plugin was born when I wrote my essay on philosophy.  Those who had written 
conspectus in institute or college for considerably long time, have their 
own system of abbreviations, so do I.  And I wanted to have those 
abbreviations available not only when I use my pen and paper, but also when 
I use Vim.  :)  So I wrote this plugin.

Unfortunately, it is not complete by now.

It works as following.  You specify root of word and its shortened version, 
also you specify possible prefixes and suffixes.  For this data 
abbreviations are generated.  I had not found another way, so I define 
abbreviation via |:abbr| for each combination of prefix-root-suffix, so 
number of those abbreviations grows dramatically when you abbreviate new 
words.  I hadn't tested how fast it will work for large count of 
abbreviations; may be this is not the problem.  But it may turn out that 
for some sensible count of abbreviated words Vim will hang after each word 
typed, so that it became uncomfortable to input text at all.  If this will 
happen, I will have to choose another approach.

Anyway, as I've told, this plugin is not yet complete, an I hope I will 
find answers on those questions in some future.

Note: I've not tested this plugin with utf-8, and it seems to me that it 
won't work.  :(  But it works well with any single-byte encodings.  This 
version is for cp1251; if you want change this, you may recode plugin-file 
to any encoding you want: >
	:e ++enc=cp1251 t7ko\abbr.vim
	:set fenc=koi8-r
	:x
Anyway, if you find that it works with multibyte as well or find any way 
how to make it do so, write me, please, to |t7ko-bug-reporting|.

						    *t7ko-abbr-explanation*
Basic command defined by this plugin is |:Abbr|.  This command (unlike all   
the other commands in the plugin) doesn't depend on any language or 
encoding of your text.  This command does following.  Suppose you will 
issue >
	:Abbr a,the werylongroo r t ,s
( Note last argument: it shows how you can specify empty {postfix} for 
abbreviation.)  This command will generate abbreviations such that when you 
type in "art" you will get it expanded to "awerylongroot", and "therts" 
will be expanded to "thewerylongroots".  This works as following.  You type 
{prefix}, {abbr}, {common} and {postfix}, and you get {abbr} expanded to 
{root}.

Plugin doesn't try to check if abbreviations override each other, or any 
correct existing word.  This is left to you, user.  You may also need to 
read |Abbreviations| to learn some extra things you may do with them.


Here is list of commands defined by this plugin.

NOTE: to read Russian examples in this section you need to have this file 
opened with encoding utf-8, so you may need to issue command >
	:e! ++enc=utf-8
now.

								    *:Abbr*
:Abbr {prefixes} {root} {abbr} {common} {postfixes}
		Introduces new abbreviated word.  Actually it calls 
		|Abbr()| with arguments passed to it as strings.

		{root} is that part of word which is to be actually 
		shortened.  {prefixes} is comma-separated list of prefixes 
		for the {root}.  {abbr} is that sequence of letters which 
		will stand for {root} in abbreviation.  {common} is those 
		letters which will appear in all the possible combinations 
		of prefix-root-common-postfix and are not shortened, i.e.  
		they will also appear in all the combinations 
		prefix-abbr-common-postfix.  {postfixes} is comma-separated 
		list of postfixes for the {root}.

		NOTE:  Command is implemented via function |Abbr()| and 
		{prefixes} {postfixes} are then passed to another 
		implementation-defined function via "..." arguments.  This 
		means, that count of possible prefixes and postfixes is 
		limited by maximal arguments count allowed by Vim.  Version 
		6.3, which I use now, allows up to 20 arguments be passed 
		to function, so you may specify up to 16 {prefixes} and 
		{postfixes}.

		If {root} allows empty prefix, this may be specified by 
		adding extra comma at any place of {prefixes}.  If word has   
		no prefixes at all, specify single comma as {prefixes}.  
		The same concerns {postfixes}.

		If abbreviation has no {common} part, specify "-" (minus 
		letter) as {common}.

		See |t7ko-abbr-explanation| for details.

								   *Abbr()*
Abbr( {prefixes}, {root}, {abbr}, {common}, {postfixes} )
		Introduces new abbreviated word.  See |:Abbr| for details 
		of how it is performed.

							  *t7ko-abbr-parts*
Command for abbreviating Russian adjectives are listed in 
|t7ko-abbr-adjective|, for nouns in |t7ko-abbr-noun|.  Other parts of 
speech are coming soon.  :)  If you write commands for them himself, 
please, send them to me to |t7ko-bug-reporting|.


						      *t7ko-abbr-adjective*
Abbreviations for Russian adjectives are provided via commands 
|:AbbrAdjectiveI| and |:AbbrAdjectiveY|.

Actually each of those commands calls |:Abbr| with passed arguments and 
appropriate {postfixes} added.

							  *:AbbrAdjectiveI*
:AbbrAdjectiveI {prefixes} {root} {abbr} {common}
		Abbreviates Russian adjective with soft endings, like in 
		"хороший" or "плохой".

		See also |t7ko-abbr-adjective|.

							  *:AbbrAdjectiveY*
:AbbrAdjectiveY {prefixes} {root} {abbr} {common}
		Abbreviates Russian adjective with strong endings, like in 
		"красивый".

		See also |t7ko-abbr-adjective|.


							   *t7ko-abbr-noun*
Abbreviations for Russian nouns are provided via commands:
for 1-st declension: |:AbbrNounIA| and |:AbbrNounIJa|;
for 2-nd declension: |:AbbrNounIIO|, |:AbbrNounIIE|, |:AbbrNounIIJ|, 
		     |:AbbrNounIISo|, |:AbbrNounIISt|;
for 3-rd declension: |:AbbrNounIIISo| and |:AbbrNounIIISh|.

Actually each of those commands calls |:Abbr| with passed arguments and 
appropriate {postfixes} added.

							      *:AbbrNounIA*
:AbbrNounIA {prefixes} {root} {abbr} {common}
		Abbreviates Russian noun of 1-st declension with strong 
		endings, like in "мама".

		See also |t7ko-abbr-noun|.

							     *:AbbrNounIJa*
:AbbrNounIJa {prefixes} {root} {abbr} {common}
		Abbreviates Russian noun of 1-st declension with soft 
		endings, like in "тётя".

		See also |t7ko-abbr-noun|.

							     *:AbbrNounIIO*
:AbbrNounIIO {prefixes} {root} {abbr} {common}
		Abbreviates Russian noun of 2-nd declension which in 
		nominative has ending "o", like in "окно".

		See also |t7ko-abbr-noun|.

							     *:AbbrNounIIE*
:AbbrNounIIE {prefixes} {root} {abbr} {common}
		Abbreviates Russian noun of 2-nd declension which in 
		nominative has ending "e", like in "поле".

		See also |t7ko-abbr-noun|.

							     *:AbbrNounIIJ*
:AbbrNounIIJ {prefixes} {root} {abbr} {common}
		Abbreviates Russian noun of 2-nd declension which in 
		nominative has ending "й", like in "Конфуций", or 
		"чистоплюй".

		See also |t7ko-abbr-noun|.

							    *:AbbrNounIISo*
:AbbrNounIISo {prefixes} {root} {abbr} {common}
		Abbreviates Russian noun of 2-nd declension which in 
		nominative ends in soft sign, like "конь".

		See also |t7ko-abbr-noun|.

							    *:AbbrNounIISt*
:AbbrNounIISt {prefixes} {root} {abbr} {common}
		Abbreviates Russian noun of 2-nd declension which in 
		nominative has no ending, like "стол".

		See also |t7ko-abbr-noun|.

							   *:AbbrNounIIISo*
:AbbrNounIIISo {prefixes} {root} {abbr} {common}
		Abbreviates Russian noun of 3-nd declension with soft 
		endings, like in "ель".

		See also |t7ko-abbr-noun|.

							   *:AbbrNounIIISh*
:AbbrNounIIISh {prefixes} {root} {abbr} {common}
		Abbreviates Russian noun of 3-nd declension with strong 
		endings, like in "мышь".

		See also |t7ko-abbr-noun|.


==============================================================================
							      *t7ko--align*
3.2.  Align (align)~

Main idea of this plugin came from some vimtip #894 by Nall-ohki.  
Actually, I wanted this functionality long before I found that tip, but 
somehow I didn't think it is so easy to be implemented.  So when I read 
that tip I just took function listed in it and put as a plugin.  Some time 
later I made modification which made plugin more useful for me.

So, thanks a lot to Nall-ohki, author of that tip.


This plugin provides commands to align some pieces of text on a vertical 
line.

A very important note: commands provided by plugin don't handle tabs 
appropriately, because <tab> is essentially a single character, but looks 
like many spaces, and therefore prevent alignment provided by following 
commands.  But, anyway, if you use tabs, you most probably don't need this 
plugin.  :)

						   *t7ko-align-explanation*
Align means following.  Suppose, you have following text:
   1,2,3
   4,5,6
   7,8,9
   10,11,12
and you want this to look like table.  You may achieve that by using 
|:Align| and |:AlignF| commands.  For example: >
	:Align ,\zs\d ,\zs\d\+$
results in
   1, 2, 3
   4, 5, 6
   7, 8, 9
   10,11,12
and >
	:AlignF S ,\zs\d ,\zs\d
results in
   1,  2,  3
   4,  5,  6
   7,  8,  9
   10, 11, 12

The example above is quite simple and almost unusable.  Of course, you may 
perform the same with your hands, and quite fast, too.  But, having spent 
some time on exercises, you will get a very powerful tool in your hand.  
Believe me.

								   *:Align*
:{range}Align {rex1} {rex2} ...
		Aligns text specified by {range} (default -- current line) 
		using |regular-expression| {rexN} (up to 19 {rex} is 
		allowed).  For each {rex} the following operations are 
		performed.  Lines of range are scanned to find those 
		matching {rex}.  Then maximal column, at which {rex} match 
		begins, is calculated for all those lines.  Note that you 
		may use |/\zs| to change default {rex} beginning.  After 
		that in each line considerable amount of spaces is inserted 
		to make {rex} for this particular line begin at the same 
		column, as that maximum calculated before.  Note again, 
		that spaces are inserted in position when match of {rex} 
		begins, and if you use |/\zs|, spaces will be inserted in 
		position, where you placed it.

		This procedure is repeated for all the specified {rex}.  
		Note that {rex}es are treated as being independent, so if 
		{rex2} always matches on that place where {rex1} matches 
		(after alignment), than |:Align| will just try to realign 
		that part of text which is already aligned when processing 
		{rex1}.  This is sometimes annoying (e.g. when you try to 
		align several fields with the same delimiter), but some 
		tricks may be used to avoid this problem (see 
		|t7ko-align-explanation| for example).

		Actually all the work of this command is performed by 
		function |Align()|, which is called with empty {commands} 
		when |:Align| is issued.

		See also |t7ko-align-explanation|.

								  *:AlignF*
:AlignF {commands} [{cmd-args}] {rex1} {rex2} ...
		Does the same as |:Align| but also allows to change some 
		aspects of what is done via {commands} and {cmd-args}.  
		Note that for this command total count of args is limited 
		by 20.

		{commands} is a string with each letter specifying some 
		"command", which modifies behaviour of |Align()| in some 
		way.  For some of these commands an argument must be 
		supplied.  Those {cmd-args} are placed immediately after 
		{commands} as distinct command-line arguments.

		Now following commands are supported:

		i {expr}
			"Conditional" command.  Tells |Align()| not to 
			align those lines, for which {expr} evaluates to 
			false, even if {rex} matches in it.  You may use 
			variable sln which denotes line being checked.  It 
			is supposed that {expr} will not change anything, 
			otherwise |Align()| will do something else, but not 
			alignment...
			For example, >
				:%AlignF i sln!~'^#' ,
<			will align commas on all lines in file, except 
			those starting with # character.

		c {char}
			"Char" command.  Tells |Align()| to insert {char} 
			in place of space to align text.  It's supposed 
			that {char} is really single character.  You may, 
			of course, try to experiment passing longer 
			strings, but that was not meant when writing 
			plugin.

		s {string}
			"Shift" command.  Tells |Align()| to insert 
			{string} just after chars inserted to align text.  
			For example, >
				:%AlignF s $\  ,
<			will align commas in file and insert sting "$ " 
			before each one.  See also following command.

		S
			"Shift by space" command.  Is essentially the same 
			as specifying command "s" with single space as 
			argument.  Inserts extra space after alignment.

		Actually all the work of this command is performed by 
		function |Align()|, which is called when |:Align| is 
		issued.

		See also |t7ko-align-explanation|.

								  *Align()*
Align( {commands}, {rex1}, {rex2}, ...) range
		Performs alignment.  See |:AlignF| for details of how it is 
		performed.


==============================================================================
							       *t7ko--diff*
3.3.  Diff (diff)~

You know what a powerful tool is |diff|.  Especially nice is that fact, 
that Vim distributive includes it.  Vim can manage diffs between files, but 
sometimes it's necessary to see and merge differences between directories.  

As for me, I need it quite often, because I have to synchronize files at my 
home computer and at my work, and only one way I can do that, is to use my 
USB-bar.  So, when I login to my home or work computer, first I do is 
merging differences of certain directories between computer and USB-bar.  
Actually, there are some additional functions and commands, that help me 
doing that, but they are not included in this plugin-set.  I'm sure they 
will, in some future version.

Plugin defines following commands an functions.

								   *Diff()*
Diff( {dir-left}, {dir-right} )
		Performs diff on two dirs passed as args.  See |:Diff| for 
		details of how it is performed.

								*:DiffOpen*
:DiffOpen
		Opens new window with results of previous |:Diff|.

								    *:Diff*
:Diff {dir-left} {dir-right}
		Performs diff on dirs {dir-left} and {dir-right}.  Actually 
		calls |Diff()| and passes arguments to it.  See below for 
		explanation what is done when you issue the command.

								*g:DiffPrg*
To create diffs "diff" program is used.  I use this plugin under Linux and 
under Windows.  Under Linux it's supposed that "diff" is in your path.  
Under Windows plugin believes that "diff.exe" is in $VIMRUNTIME dir.  
Variable |g:DiffPrg| defined when loading the plugin contains string, which 
being passed to |:!| will run "diff" program.

I'm used to work under Linux, so I've got horrible time when trying to 
compose that string for Windows.  Now it works on those computers I use, 
but I'm not sure it will work on all others Windows-machines.  If you have 
some troubles or suggestions how to solve them, write me to 
|t7ko-bug-reporting|.

You may freely change |g:DiffPrg| to specify correct path to "diff" 
executable, but make sure you do that AFTER loading plugin, otherwise it 
will be overridden.

					 *t7ko-diff-window* *g:DiffTmpName*
Results of diff are stored in a file, whose name is the value of variable 
|g:DiffTmpName|.  Variable is initialized and file is created when |:Diff| 
is issued first time.  It is initialized using |tempname()|.  NOTE:  You 
may assign your own value to it before first call to |:Diff|; in this case 
variable will not be assigned a new value.  But I strongly recommend you 
not to do so.  What for, anyway?

Results of diffing are transformed so that look more friendly and allow 
some operations on them.

On the top of the window are shown directories, on which diff is performed.  
"Local dir" denotes first arg of |:Diff|, "Remote dir" denotes second one.  
These lines are "head" of file and will not be considered in following 
description.

The rest of file (i.e. lines that are not "head") describes differences 
between local and remote dir.  Each line contain one file or dir.  Its name 
contains path relative to local or remote dir, or to both, depending on 
where it now resides.  Line begins with 3 characters, which indicate status 
of that file/dir.  Following combinations are possible:

"<> "	File with that name exists in both local and remote dirs, and there 
	are some differences between versions of file in local and in 
	remote dir.

"<  "   File/dir with that name exists only in remote dir.

" > "   File/dir with that name exists only in local dir.

"   "   Directory with that name exists in both local and remote dirs, but 
	there are some differences in it's structure or/and containing 
	files in between its versions in local and remote dirs.

For convenience considerable amount of |folds| are created, one for each 
directory or subdirectory.  So, when diffing dirs with complex structure 
and a lot of differences, first thing you will probably do after |:Diff| is 
|zM|.

NOTE that you may change this file in any way you like.  You may delete any 
lines, or add arbitrary new ones.  This will not break availability of 
operations, described below in |t7ko-diff-mappings|.  The only thing that 
is to be kept unchanged in this file is those 3 characters at the beginning 
of lines.  They are used by commands to determine which operations are 
available on those lines.  But, if you need, you may edit them, too.  This 
will help you to do some tricks, which were not meant when creating this 
plugin.  :)

						       *t7ko-diff-mappings*
|:Diff| defines some mappings for performing different operations on those 
files listed in the diff-window.  (They are, of course, defined as local 
ones, for not to pollute global space.)

I could create local command for each of these mappings, too, but I 
decided, that this is not necessary.  If you need these operations in 
command line, you may use |:normal| and, maybe, |:execute|.  For example: >
	:%g/^<  /normal c
copies from remote dir all the files that are absent in local dir.  (^Q is 
typed as <c-v><c-q>, or <c-q><c-q>, which is faster.)

					     *CTRL-Q_u*  *t7ko-diff-update*
CTRL-Q_u	Updates diff results, i.e. issues |:Diff| with the same 
		arguments it was issued to create current results.  All the 
		changes made in text of diff-window are lost.  You will use 
		this command if you have used some of following commands 
		and want to check results.

					     *CTRL-Q_o*    *t7ko-diff-open*
CTRL-Q_o	Opens file/dir, which is absent in local or remote dir, in 
		new window.

					     *CTRL-Q_c*    *t7ko-diff-copy*
CTRL-Q_c	Copies file/dir, which is absent in local or remote dir, in 
		the dir where it is absent from that dir, where it is 
		present.

					     *CTRL-Q_r*  *t7ko-diff-remove*
CTRL-Q_r	Removes file/dir, which is absent in local or remote dir, 
		from that dir where it is present.  Unlike other commands, 
		defined in this window, this asks you for confirmation.  
		This will be annoying if you want to delete a lot of files, 
		but why not use file manager, or shell, provided by system, 
		for that purpose, eh?

					     *CTRL-Q_d*    *t7ko-diff-diff*
CTRL-Q_d	Makes |:diffsplit| on versions of file in local and remote 
		dirs.  Note that it tries to close all opened windows and 
		to leave only those two versions opened in Vim.  If you 
		want go back to diff-results, use |:DiffOpen|.


==============================================================================
							      *t7ko--float*
3.4.  Floating point operations (float)~

Vim doesn't provide operations on floating-point numbers.  Once I've got a 
strong need in such an ability, and had written this plugin.  NOTE that 
much easier and efficient way is to use Perl, or GNU BC, or whatever else.  
When I wrote the plugin, I didn't have anything of it under Windows.  But I 
found GNU BC here:
	http://sourceforge.net/projects/gnuwin32/
and this plugin became no more strong necessary for me.  I didn't implement 
multiplication and division of numbers, and, probably, will never do that.  
If you will, mail me to |t7ko-bug-reporting|, I'll include that code in 
plugin.  Thanks in advance.

Numbers are stored as strings.  Decimal delimiter is point.  You may use 
only direct form, exponential form (like "1e5") is not implemented.  No 
spaces or any other characters except - or + at the beginning, and numbers, 
optionally delimited with single decimal point.

Here are available functions that manage these "numbers".

								 *FloatQ()*
FloatQ( {num} )
		Returns true if {num} is a number which can be handled by 
		following functions.

							    *FloatAssert()*
FloatAssert( {num} )
		Throws exception if FloatQ({num}) returns false.  All the 
		functions except |FloatQ()| use this function to ensure 
		that their arguments are valid "numbers".

							  *FloatSimplify()*
FloatSimplify( {num} )
		Returns {num} with unnecessary characters removed (like 
		trailing zeros after decimal point, or leading zeros, or 
		leading plus sign).

							*FloatIsNegative()*
FloatIsNegative( {num} )
		Returns true if {num} is negative.

							     *FloatEqual()*
FloatEqual( {num1}, {num2} )
		Returns true if {num1} and {num2} are equal.

							    *FloatNegate()*
FloatNegate( {num} )
		Returns negated {num}.

							 *FloatDecompose()*
FloatDecompose( {num}, {prefix} )
		Returns string, which being evaluated assigns to variables 
		{prefix}sign, {prefix}int, {prefix}flt strings representing 
		correspondent parts of {num}.  {prefix}sign is 1 or -1, 
		depending on is {num} non-negative or not.  {prefix}int and 
		{prefix}flt are set to "0" if they are empty in {num}.  
		Note that {num} is not changed in any way before its 
		decomposition.  So, for example, >
			:exe FloatDecompose("00.00","")
<		will set vars int and flt to "00", not to "0".

							     *FloatRound()*
FloatRound( {num}, {dig} )
		Returns {num} rounded to the power {dig} of 10.  For 
		example, >
			:echo FloatRound('11.11', 1)
			:echo FloatRound('11.11',-1)
<		will result in
			 10
			 11.1

							       *FloatAdd()*
FloatAdd( {num1}, {num2} )
		Returns the sum of {num1} and {num2}.  It uses integer 
		operations available in vim, so you may not use {num}s 
		having integer or floating-point pars larger than max value 
		which may store int on your machine.

							       *FloatDis()*
FloatDis( {num1}, {num2} )
		Returns {num1} decreased by {num2}.

							      *FloatMult()*
FloatMult( {num1}, {num2} )
		Should return the product of {num1} and {num2}, but is not 
		implemented.  Sorry.

							       *FloatDiv()*
FloatDiv( {num1}, {num2} )
		Should return the quotient of division {num1} by {num2}, 
		but is not implemented.  Sorry.


==============================================================================
								*t7ko--mat*
3.5.  Matematika-like loops (mat)~

Plugin implements loops as in Matematika.

This plugin was written long ago, and is used very rarely.  I don't know 
why.  May be because I hadn't implemented these loops as commands in 
addition to functions, when I wrote it...  Or maybe because they should be  
never used at all.

							 *MatDo()* *:MatDo*
MatDo( "{stmt}", {ntimes} )	OR
:MatDo {stmt} {ntimes}
		Does |:execute| {stmt} {ntimes} times.  Example: >
			:MatDo echo\ 'Hi' 5
<
						       *MatFor()* *:MatFor*
MatFor( "{stmt}", "{varname}", {begval}, {endval}, {increment} )
:MatFor {stmt} {varname} {begval} {endval} {increment}
		Assigns to variable {varname} values of interval {begval} 
		to {endval} with increment {increment}, and for each value 
		does |:execute| {stmt}, so you may use {varname} in {stmt}.  
		Note that {varname} is treated as variable local to a 
		function, so its global value will not be changed.  If you 
		want to use global variable, you must specify that 
		explicitly by prepending g: to its name (see also |g:var|).  
		Example: >
			:MatFor echo\ i i 1 5 1
<

==============================================================================
							   *t7ko--position*
3.6.  Position handling (position)~

This plugin appeared when I've got a necessity to do "hyperlinks" from one 
file to exact positions in others.  Of course you may use vimscript #293 by 
Stefan Bittner from
	http://www.vim.org/scripts/script.php?script_id=293
to achieve that.  But note that functions of my plugin are more 
developer-oriented, and they allow some extra functionality.  For example, 
you may easily create |quickfix| list from a set of those "hyperlinks" 
created with functions of this plugin (see |:PositionListCOpen|.
 
						*t7ko-position-explanation*
Plugin accomplishes two general tasks.  First is work with those 
"hyper-links", and second is saving and restoring position inside window.  
They are explained below in following sections:
  3.6.1.  Hyperlinks                     |t7ko-position-hyperlinks|
  3.6.2.  Screen position save/restore   |t7ko-position-position|


3.6.1.  Hyperlinks~
						 *t7ko-position-hyperlinks*
Hyperlinks are managed in following way.  You move cursor to position in 
file you want to set hyperlink to.  Then you press |CTRL-Q_ps| or issue 
|:PositionSave| (which is actually performed when you press |CTRL-Q_ps|).  
After that you have in your default vim buffer and in system clip-buffer a 
string, which is a "hyperlink" to current position.  It has following form: 
>
	<filename|line|column>
Now you can place this anywhere you want, and later you may go to the place 
it "hyperlink" points to, by placing cursor over it and pressing 
|CTRL-Q_pr| or issuing |:PositionRestore| (which is actually performed when 
you press |CTRL-Q_pr|).

{Filename} is taken as @% (see |@| and |quote%|).  This means that paths 
are sometimes relative and sometimes absolute, depending on where is file 
located relative to current work directory.  This means that those 
"hyperlinks" will probably be valid only when you are in the same 
directory, where you were when "hyperlink" was created.  But I always use 
these hyperlinks only inside a session (see |t7ko--sess|), and I never 
change working directory for that session.  So I have none of those 
troubles.  However, if you encountered them, or even found a solution, 
which is more general, mail me to |t7ko-bug-reporting|.


						*CTRL-Q_ps* *:PositionSave*
CTRL-Q ps		OR
:PositionSave
		Composes hyperlink string of form >
			<filename|line|column>
<		and stores it in default Vim register (as when using |y|) 
		and in system clip-buffer (ctrl+ins under Windows).
		
		{filename} is the value of @% for current buffer, {line} 
		and {column} are current line and column (i.e.  position 
		where cursor is).

		See also |t7ko-position-hyperlinks|.

					     *CTRL-Q_pr* *:PositionRestore*
CTRL-Q pr		OR
:PositionRestore
		When cursor is positioned on a hyperlink, i.e. on string of 
		form >
			<filename|line|column>
<		then new buffer is opened for file {filename} and cursor is 
		positioned on line {line} and column {column}.

		See also |t7ko-position-hyperlinks|.

				 *:PositionListCOpen* *PositionListCOpen()*
:[range]PositionListCOpen	OR
PositionListCOpen() [range]
		These create |quickfix| from a list of hyperlinks listed on 
		lines in a [range], one (or zero) hyperlink per each line, 
		followed by an optional comment.  Example: >
			TODO list.
			<qwer.txt|1|1> add new text
			<qwer.txt|2|1> remove some text
			<qwer.txt|3|1> and here we have such a long remark, 
					that it doesn't fit in a single 
					line, but is still valid input to 
					the command and will appear in 
					quickfix window, too.
<		Select these lines and type :PositionListCOpen<cr>

		See also |t7ko-position-hyperlinks|.


3.6.2.  Screen position save/restore~
						   *t7ko-position-position*
I write a lot of functions that apply some changes to text in opened 
buffer.  During their work current position (i.e. current line and column) 
often changes (like after |:s|), so I wrote two functions which help me in 
saving and restoring screen position.  These functions are |PositionCmd()| 
and |PositionSCmd()|.  Both return a string, which being executed via 
|:execute| restores screen position.  The way I use them is: >
	let spos=PositionSCmd()
	try
		... here I perform operations specific to a function this 
		... code belongs to ...
	finally
		execute spos
	endtry
This guarantees that screen position is always restored.

							    *PositionCmd()*
PositionCmd()
		Returns a string, which being executed via |:execute| will 
		move cursor to the position, where it was when command was 
		executed.  This works essentially like using local |mark|, 
		with that advantage, that you can set and jump it "locally" 
		inside a function, not worrying about you may reset a 
		|mark|, which is already in use.

							   *PositionSCmd()*
PositionSCmd()
		This is an extension to |PositionCmd()|.  Returns a string 
		which being executed via |:execute| will do the same as if 
		you use |PositionCmd()|, but also will move content of 
		buffer so that top line will be restored too (this may fail 
		if you make window too small between call to 
		|PositionSCmd()| and |:execute|).


==============================================================================
							       *t7ko--sess*
3.7.  Sessions management (sess)~

As times go by, Vim becomes more and more wholesome to me.  It is like my 
shell, interface between me and those text files lying on my hard disk (and 
not only text files).  On my work (and partly at home) I use it as IDE -- 
it remembers all files of project(s), can call external tools to build 
project, can handle errors list found by compiler.  Under windows it often 
replaces bash for me (because that poor cmd.exe not always can do what I 
want, but Vim can).

There is also lots of examples of possible use.  And usually for each of 
that "project" some set of options, mappings and commands is to be set.  
Setting them manually each time you start editing "project" becomes 
impossible as their count grows.  Vim provides a tool for helping in this 
situation -- this is |session-file|.  There is some details about it: Vim 
doesn't store some things (e.g. functions, commands, autocommands, syntax 
items).  You can use extra-file which is loaded by session-file itself just 
before it finishes its work.  Details about this file you may read here: 
|session-file|.  (The only thing I wish to add to that is: the way how 
extra-file is loaded allows you to change extension of |session-file| to 
any one you like.  Just read some session-file generated with |:mksession| 
to understand how it works.  This fact was used when designing 
|:SessOSSwitch|.)

This is almost what I needed.  This plugin contains some commands, 
functions, and mappings, which help me to use this feature of Vim more 
effectively and quickly.

						    *t7ko-sess-explanation*
First thing which I made when I've read about |session-file| was: >
	:nmap <c-z>l :execute 'mksession!' v:this_session<cr>
This saves currently opened session in the same session-file.  (Some time 
later I created command |:SessSave| and corresponding function, which does 
the same as mapping above, but more carefully, e.g. it checks if there is 
any loaded session at all.  Now mapping is left, but it just calls 
|:SessSave|.)  Just after creating that mapping I discovered that I often 
need to modify extra-file.  So I had to type something like (supposing that 
session-file has extension ".vim"): >
	:new <c-r>=v:this_session<cr><left><left><left><left>x<cr>
This annoyed me, and I created function |SessExtraFname()|, which returns 
name of extra-file for currently loaded session, and command 
|:SessExtraOpen|, which opens that extra-file for editing.  After that, for 
not to type >
	:source <c-r>=SessExtraFname()<cr><cr>
I created command |:SessExtraReload|.  And some time later I added 
autocommand (in group |SessAuGroup|), which calls |:SessExtraReread| 
whenever you leave buffer with extra-file.

After some considerable time of using those mentioned above, I realized yet 
another problem which is to be solved.  I often edit the same "project" 
from under Windows and Linux.  But in this case I cannot use |session-file| 
directly, because often session-file created under Windows causes errors 
when opened under Linux, and vice versa.  First time I did nothing with 
that.  Than I recollected that session-file may have any extension I like, 
so that I may create two (or more) session-files with different extensions, 
but they will still use the same extra-file.  After that I wrote simple 
dispatcher as a distinct file, which loaded appropriate session-file 
depending on the current OS.  And, finally, I synthesized that code into a 
command |:SessOSSwitch|, which released me from writing any dispatching 
code.  It works as following.  Let's say, usually your session-files have 
extension ".vimsession" (like mine :).  You want to create session "zz", 
which will be loadable under Windows and Linux.  You create the "master" 
session-file "zz.vimsession" and put there two lines: >
	PlugIn sess
	SessOSSwitch
Then, under Windows, you run vim and set up all the options or whatever you 
need.  Then you save it into "slave" session-file with name zz.OS-win32: >
	mksession zz.OS-win32
Under Linux you do the same, but with name of slave session-file 
zz.OS-unix.  Now you may run master session-file with >
	vim -S zz.vimsession
which will load appropriate file (performs "dispatching").  Actually, 
|:SessOSSwitch| will look for all files with name zz.OS-* in the same 
directory, where zz.vimession is, and then |:source| first of them, for 
which that star expands to existing Vim feature (see |has()|).

Now yo may use all those commands and mappings, described in this section, 
and they will work correctly.  |:SessSave| will save session to appropriate 
zz.OS-* file, |:SessExtraOpen| will open extra, which is the same for all 
OS-specific session-files.  Voila.

Some time later I understood that this architecture of session-files (with 
one master and a set of slaves) may be used for executing some commands or 
setting some options before session is loaded.  This may be useful to 
defining your own syntax, or autocommands, which should fire when files are 
opened, and therefore must be defined _before_ vim loads session.  But I've 
not tried that yet.  If you do that before me, write me please (see 
|t7ko-bug-reporting|).


					*:SessSave* *SessSave()* *CTRL-Z_l*
:SessSave		OR
SessSave()		OR
CTRL-Z_l
		Saves current settings into |session-file| of currently 
		loaded session.

							 *SessExtraFname()*
SessExtraFname()
		Returns name of extra-file for currently loaded session or 
		fires error-message if no session is loaded.

					 *:SessExtraOpen* *SessExtraOpen()*
:SessExtraOpen		OR
SessExtraOpen()
		Opens extra-file (uses |SessExtraFname()| to get its name).  
		Also defines autocommand (in group |SessAuGroup|) which 
		|:source|s the extra-file when you leave it.

							 *:SessExtraReread*
:SessExtraReread
		Does |:source| extra-file (uses |SessExtraFname()| to get 
		its name).

							      *SessAuGroup*
SessAuGroup
		Autocmd-group (see |:augroup|).  Contains autocommand which 
		|:source|s extra-file when you leave it.

					   *:SessOSSwitch* *SessOSSwitch()*
:SessOSSwitch		OR
SessOSSwitch({session})
		Does |:source| OS-specific session-file for session being 
		loaded, or fails if none is found.  {session} is full path 
		of master session-file with extension removed.  See 
		|t7ko-sess-explanation| for details.  Advice: don't use 
		function, use command instead (unless you're going to do 
		some trick;  :)  if you do -- tell me, what it consists in, 
		see |t7ko-bug-reporting|).


==============================================================================
							       *t7ko--sort*
3.8.  Sorting (sort)~

One day I was editing some file under Window.  I needed to sort that file.  
Somehow I recollected, that I've seen somewhere in Vim-help an example of 
function which sorts lines inside a range.  I found that example and 
shamelessly copied it an save as a plugin-file.  Than I discovered, than 
when that function is run to sort a range which is large enough, it fails, 
because it is implemented via recursion and recursion depth is limited in 
Vim.  So I wrote my own sorting function, which appeared to be very slow in 
comparison with


These functions and commands have at least one advantage in comparison with 
commands provided by OS environment.  This is: they use current Vim 
settings, related to encoding of file, when comparing strings.  I'm not 
sure that command SORT provided by Windows will be able to sort file, which 
is in utf-8, or at last in koi8-r.  (You know, I'm not sure, it will sort 
any text at all, except encoded as cp866.)


==============================================================================
							       *t7ko--text*
3.9.  Text (text)~

Last time I often edit text files.  And I discovered set of options which 
help me in doing that.  And I wanted to have those options saved in some 
place which will always be available for me in Vim.  I created this plugin 
and function in it, which places all the necessary modelines at the current 
cursor position.

Also, I often include code pieces in a text file, which is for my own 
purpose.  It is quite nice, when those pieces are highlighted properly.  
Once I saw an example of how it may be achieved, and having taken it as a 
basis, I created command |:TextEnableCodeSnip| which enables highlighting 
of such code snippets, and put it in this plugin.

				     *:TextVimlinesPut* *TextVimlinesPut()*
:TextVimlinesPut
TextVimlinesPut()
		Puts several modelines which contain set of options those I 
		found convenient for editing text files.  Sorry, if they 
		are not appropriate for you.  If you find any other useful 
		things, please, let me know via |t7ko-bug-reporting|.

			       *:TextEnableCodeSnip* *TextEnableCodeSnip()*
:TextEnableCodeSnip {filetype} {start-pattern} {end-pattern}
TextEnableCodeSnip( {filetype},{start-pattern},{end-pattern} )
		Tells Vim to highlight text between each pair of 
		{start-pattern} and {end-pattern} matches as it is of type 
		{filetype}.  For example, after typing >
			:TextEnableCodeSnip c <CODE> </CODE>
<		you will have text between <CODE> and </CODE> highlighted 
		as C program.  Command is designed so that it allows you to 
		use command line expansion on first argument ({filetype}).

		Note that you may |:PlugIn| this plugin, than 
		|:TextEnableCodeSnip|, and after that |:PlugOut| the 
		plugin.  Syntax highlighting will still work after that.

		Note also that using double-quote in {start-pattern} and 
		{end-pattern} won't work properly, due to the way I 
		implemented the command.  I hadn't tried to fix it, because 
		I don't need it.  But if you find any (elegant) way how to 
		get over this problem, please, let me know via 
		|t7ko-bug-reporting|.


==============================================================================
							       *t7ko--uniq*
3.10. Making lines unique (uniq)~

Soon after I wrote plugin |t7ko--sort|, I found that I need some analogue 
of Linux tool uniq.  It takes sorted lines, and makes removes duplicate 
lines.  This was easy and fast to implement.  Here it is.

							   *:Uniq* *Uniq()*
:[range]Uniq
Uniq() range
		Being run on a range containing sorted lines, removes 
		duplicates.  Note that text must be sorted prior to calling 
		this command, this command itself does not sort lines.  It 
		just finds each line within range which coincide with 
		previous one and deletes it.


==============================================================================
							    *t7ko--windiff*
3.11. Enabling diff under Windows (windiff)~

Last year I worked under Windows a lot.  It often disturbs me with it's 
complex and awkward rules of how filenames with special symbols (like 
space) are treated, and with it's backslash as directory delimiter and at 
the same time -- escape character...  Those who ever worked under Linux 
will understand what I mean.

Yet another point where that error fires again is using |vimdiff|.  This 
problem doesn't touched those who includes $VIMRUNTIME to his system PATH 
environment variable, or copied executables to windows system path.  I 
hadn't done anything of it (I had reasons), so when I first time had typed 
|:diffsplit|, Vim hadn't found diff executable.  After very long 
experiments with single quotes, double quotes and some other tricks, (and 
after reading example given in |diff-diffexpr|) I found how to use 
$VIMRUNTIME correctly when it contains spaces.  And saved result as this 
plugin.

And, once again, this is designed especially for those Windows.  I wonder, 
why don't they make their batch-files syntax more friendly?...

This plugin doesn't define any commands or functions you will use directly.  
Being plugged in, it defines one function, |Windiff()|, which is designed 
to be used as 'diffexpr', and sets 'diffexpr' appropriately.  It also saves 
value of 'diffexpr' before resetting, and restores it when plugging out.

								*Windiff()*
Windiff()
		Designed to be used as 'diffexpr' under Windows.  Executes 
		diff.exe no matter is it in PATH or not (it is expected to 
		be found in $VIMRUNTIME directory).


vim:tw=75:ts=8:sw=8:noet:ft=help:
